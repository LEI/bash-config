#!/usr/bin/env bash

# set -e
set -o pipefail

ROOT="$(cd "$(dirname "$BASH_SOURCE")"; pwd -P)"

# declare -l OS
# OS="$(uname -o 2>/dev/null || uname -s)"
# OS="$(echo "$OS" | tr '[:upper:]' '[:lower:]')"

for f in $ROOT/lib/*.bash
do source "$f"
done

check() {
  if [[ $# -ne 0 ]] && [[ -n "$1" ]] && [[ "$1" -ne 0 ]]
  then err "${2:-1}: already defined"
    return 1
  fi
}

prompt() {
  local q="$1"
  local d="$2"
  >&2 log "$q"
  local reply
  read -r reply
  # read -p "$q" -i "$d" -e vareply
  log "${reply:-$d}"
}

find_names() {
  [[ $# -eq 0 ]] && return 1
  local names=("$@")
  local exp=("(")
  local i
  for i in "${!names[@]}"
  do [[ "$i" -ne 0 ]] && exp+=("-o")
    exp+=("-name" "${names[$i]}")
  done
  exp+=(")")
  printf "%s\n" "${exp[@]}"
}

find_packages() {
  local path="$ROOT"
  local i ignore=(".git" "os_*" "lib")
  local find_args=("$path")
  [[ -d "$path/os_$OS" ]] && find_args+=("$path/os_$OS")
  find_args+=("-mindepth" "1" "-maxdepth" "1" "-type" "d")
  if [[ "${#ignore[@]}" -ne 0 ]]
  then find_args+=("!")
    while read -r i
    do find_args+=("$i")
    done < <(find_names "${ignore[@]}")
  fi
  if [[ $# -ne 0 ]]
  then find_args+=("-a")
    while read -r i
    do find_args+=("$i")
    done < <(find_names "$@")
  fi

  # if [[ "${verbose:-0}" -ne 0 ]]
  # then >&2 log "find ${find_args[*]}" $(find "${find_args[@]}" -print)
  # fi

  find "${find_args[@]}" -print0
}

main() {
  detect_os || return 1
  local target="$HOME"
  local RUN=1
  local a action="install"
  local pm=0
  local sync=0
  local update=0
  local verbose=0
  local options="[hIDSuvd]"
  local pkg=()
  [[ $# -eq 0 ]] # && set -- "-uIS"
  while [[ $# -ne 0 ]]
  do case "$1" in
      --) shift; break ;;
      -h|--help) log "Usage: $options [--no-packages] [--no-sync]"; return ;;
      -I|--install) check "$a" "$1" && a="install" && pm=1 || return 1 ;;
      -D|--delete) check "$a" "$1" && a="delete" && pm=1 || return 1 ;;
      -S|--sync) check "$sync" "$1" && a="${a:-0}" && sync=1 || return 1 ;;
      # -D|--delete) check "$a" "$1" && a="delete" && sync=1 || return 1 ;;
      -u|--update) check "$update" "$1" && update=1 && pm=1 ;;
      -v|--verbose) verbose="$(($verbose + 1))" ;;
      -d|--dry-run) RUN=0 ;;
      --no-packages) pm=0 ;;
      --no-sync) sync=0 ;;
      --*|'') err "$1: illegal option $options"; return 1 ;;
      -*) if [[ "$1" =~ ^-[a-zA-Z][a-zA-Z]+$ ]] && [[ "${1:1:1}" =~ $options ]]
        then set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue
        else err "${1:0:2}: illegal option $options"; return 1
        fi
        ;;
      *) pkg+=("$1") ;; # pkg+=("$@"); break
    esac
    shift
  done
  if [[ -n "$a" ]]
  then action="$a"
  else pm=1; sync=1; update=1
  fi

  export RUN verbose
  log "Bootstrap: $OS"

  local v var val
  if [[ " ${pkg[@]} " == " git " ]]
  then
    for v in "GIT_AUTHOR_NAME:What is your github full name?" \
      "GIT_AUTHOR_USERNAME:What is your github username?" \
      "GIT_AUTHOR_EMAIL:What is your github email?"
    do var="${v%%:*}"; val="$(prompt "${v#*:} (default: ${!var}) " "${!var}")"
      declare $var="$val" && export $var
    done
  fi

  # Package manager
  if [[ "$pm" -ne 0 ]]
  then
    if [[ "$update" -ne 0 ]]
    then pkg_update || return 1
    fi
    local path="$ROOT/os_$OS/packages" # ${PKG_CMD%%-*}
    if [[ -f "$path" ]] # TODO confirm
    then
      if [[ "$action" != "delete" ]]
      then pkg_$action $(cat "$path") || return 1
      fi
    else err "$path: no such file"
    fi
  fi

  # Sync dotfiles
  if [[ "$sync" -ne 0 ]] && has stow
  then
    local path
    while IFS= read -d '' -r path
    do find_stow "$action" "$target" "$path"
    done < <(find_packages "${pkg[@]}")
  fi

  log "Done."
}

# [[ "$0" == "$BASH_SOURCE" ]]
main "$@"
